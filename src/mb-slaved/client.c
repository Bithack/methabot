/*-
 * client.c
 * This file is part of mb-slaved
 *
 * Copyright (c) 2008, Emil Romanus <emil.romanus@gmail.com>
 *
 * Permission to use, copy, modify, and/or distribute this software for any
 * purpose with or without fee is hereby granted, provided that the above
 * copyright notice and this permission notice appear in all copies.
 * 
 * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
 * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
 * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
 * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
 * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
 * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
 * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
 * 
 * http://bithack.se/projects/methabot/
 */

#include <string.h>
#include <stdlib.h>
#include <syslog.h>
#include <time.h>
#include <pthread.h>
#include <mysql/mysql.h>

#include "slave.h"
#include "client.h"
#include "nolp.h"

void mbs_client_main(struct client *this, int sock);
static int get_and_send_url(struct client *cl);

static void client_event(EV_P_ ev_io *w, int revents);
static void thr_signal(EV_P_ ev_async *w, int revents);
static void timer_reached(EV_P_ ev_timer *w, int revents);

static int on_status(nolp_t *no, char *buf, int size);
static int on_url(nolp_t *no, char *buf, int size);

static int send_config(int sock);

/* nolp commands, client -> slave */
struct nolp_fn client_commands[] = {
    {"STATUS", &on_status},
    {"URL", &on_url},
    {0}
};
/** 
 * Create a new client with a random login-token
 *
 * the token is a 40-byte string representation
 * of a SHA1 hash generated by an SQL query on
 * some random values and the IP-address 
 * concatenated.
 *
 * addr should be the clients IP-address
 **/
struct client*
mbs_client_create(const char *addr, const char *user)
{
    struct client* cl;
    time_t now;
    int a, x;
    char *p;
    char q[128];
    int qlen;

    MYSQL_RES *res;
    MYSQL_ROW *row;

    if ((cl = malloc(sizeof(struct client)))) {
        if ((cl->addr.s_addr = inet_addr(addr)) == (in_addr_t)-1
                || !(cl->user = strdup(user))) {
            syslog(LOG_ERR, "invalid address/user");
            free(cl);
            return 0;
        }
        qlen = sprintf(q, "SELECT SHA1(CONCAT(CONCAT(CONCAT('%s', NOW()), RAND()), RAND()))", addr);
        if (mysql_real_query(srv.mysql, q, qlen) != 0
                || !(res = mysql_store_result(srv.mysql))
                || !(mysql_num_rows(res))
                || !(row = mysql_fetch_row(res))
                ) {
            free(cl);
            return 0;
        }
        if (row[0])
            memcpy(cl->token, row[0], 40);
        else
            return 0;

        mysql_free_result(res);

        /** 
         * add the client to the _client table which will give us an 
         * integer identifier to be used when adding URLs to the log
         * and save target urls
         **/
        qlen = sprintf(q, "INSERT INTO nol_client (token) VALUES ('%.40s');", cl->token);
        if (mysql_real_query(srv.mysql, q, qlen) != 0) {
            free(cl);
            return 0;
        }
        cl->id = (long)mysql_insert_id(srv.mysql);

        syslog(LOG_INFO,"new client %d:'%.6s...' from %s", (int)cl->id, cl->token, addr);
    }

    return cl;
}

void
mbs_client_free(struct client *cl)
{
    free(cl->user);
    free(cl);
}

void *
mbs_client_init(void *in)
{
    int sock = (int)in;
    int n;
    int x;
    char *buf;
    struct client *this = 0;

    do {
        if (!(buf = malloc(256)))
            break;

        /* first authorize this client connection */
        if ((n = sock_getline(sock, buf, 255)) <= 0)
            break;

        if (n != 6+TOKEN_SIZE || memcmp(buf, "AUTH ", 5) != 0)
            break;

        pthread_mutex_lock(&srv.pending_lk);
        for (x=0; x<srv.num_pending; x++) {
            if (memcmp(srv.pending[x]->token, buf+5, TOKEN_SIZE) == 0) {
                this = srv.pending[x];
                if (x != srv.num_pending-1)
                    srv.pending[x] = srv.pending[srv.num_pending-1];
                srv.num_pending --;
                break;
            }
        }
        pthread_mutex_unlock(&srv.pending_lk);

        free(buf);
        buf = 0;

        if (!this) {
            send(sock, "200 Denied\n", 11, 0);
            break;
        }

        /* enter main loop */
        mbs_client_main(this, sock);
    } while (0);

    if (buf)
        free(buf);
    close(sock);

    /* remove this client from the client list, 
     * if it's been added to it earlier */
    if (this) {
        pthread_mutex_lock(&srv.clients_lk);
        for (x=0; x<srv.num_clients; x++) {
            if (srv.clients[x] == this) {
                if (x != srv.num_clients-1) {
                    srv.clients[x] = srv.clients[srv.num_clients-1];
                }
                if (srv.num_clients == 1) {
                    free(srv.clients);
                    srv.clients = 0;
                } else if (!(srv.clients = realloc(srv.clients, (srv.num_clients-1)*sizeof(struct client*))))
                        abort();
                srv.num_clients--;
                break;
            }
        }
        pthread_mutex_unlock(&srv.clients_lk);
        ev_async_send(EV_DEFAULT_ &srv.client_status);
        mbs_client_free(this);
    }

    return 0;
}

void
mbs_client_main(struct client *this, int sock)
{
    struct ev_loop *loop;
    ev_io           io;

    if (!(this->no = nolp_create(&client_commands, sock)))
        return;
    if (!(loop = this->loop = ev_loop_new(EVFLAG_AUTO)))
        return;
    if (!(this->mysql = mbs_dup_mysql_conn()))
        return;

    ((nolp_t *)(this->no))->private = this;

    ev_io_init(&io, &client_event, sock, EV_READ);
    ev_async_init(&this->async, &thr_signal);

    /* move 'this' into the global list of clients
     * at srv.clients, this allows the main thread 
     * to signal this thread and retrieve data
     * from the 'this' structure */
    pthread_mutex_lock(&srv.clients_lk);
    if (!(srv.clients = realloc(srv.clients, (srv.num_clients+1)*sizeof(struct client*)))) {
        syslog(LOG_ERR, "out of mem");
        abort();
    }
    srv.clients[srv.num_clients] = this;
    srv.num_clients++;
    pthread_mutex_unlock(&srv.clients_lk);

    io.data = this->no;
    ev_io_start(loop, &io);
    ev_async_start(loop, &this->async);
    
    /* notify the main thread that we chagned the client list,
     * the slave in turn will update the master with the new 
     * list */
    ev_async_send(EV_DEFAULT_ &srv.client_status);
    this->running = 1;

    /* notify the login success to the client, and then send
     * the configuration file */
    send(sock, "100 OK\n", 7, 0);
    if (send_config(sock) == 0) {
        ev_loop(loop, 0);
    }
    ev_io_stop(loop, &io);
    ev_async_stop(loop, &this->async);
    ev_loop_destroy(loop);

    mysql_close(this->mysql);
    syslog(LOG_INFO, "client disconnected");
}

/* send the active configuration as received from the
 * master to the client, this must be done be anything else
 * is done */
static int
send_config(int sock)
{
    char out[64];
    int  len;
    len = sprintf(out, "CONFIG %d\n", srv.config_sz);
    if (send(sock, out, len, 0) <= 0)
        return -1;
    if (send(sock, srv.config_buf, srv.config_sz, 0) != srv.config_sz)
        return -1;

    return 0;
}

/** 
 * called when data is available for 
 * reading on the client socket
 **/
static void
client_event(EV_P_ ev_io *w, int revents)
{
    if (nolp_recv((nolp_t *)w->data) != 0)
        ev_unloop(EV_A_ EVUNLOOP_ONE);
}

/** 
 * receive signals from main thread
 **/
static void
thr_signal(EV_P_ ev_async *w, int revents)
{

}

/* see on_status() for why the timer is used */
static void
timer_reached(EV_P_ ev_timer *w, int revents)
{
    /* return 0 if we successfully found a URL and sent
     * it to the client */
    if (get_and_send_url((struct client*)w->data) != 0)
        ev_timer_again(loop, w);
}

#define Q_GET_NEW_URL \
    "SELECT url FROM nol_url WHERE `date` < DATE_ADD(NOW(), INTERVAL 1 DAY) "\
    "ORDER BY `date` DESC LIMIT 0,1;"

/** 
 * get_and_send_url()
 *
 * query the database for any new URL, if found
 * then send it to the client. Returns 0 if a 
 * URL was found and sent to the client, non-
 * zero on error or no URL was found.
 **/
static int
get_and_send_url(struct client *cl)
{
    MYSQL_RES *res;
    MYSQL_ROW row;
    int   sz;
    char *url;
    char *buf;
    unsigned long *lengths;
    if (mysql_real_query(cl->mysql, Q_GET_NEW_URL, sizeof(Q_GET_NEW_URL)-1) != 0)
        return -1;
    if (!(res = mysql_store_result(cl->mysql)))
        return -1;
    if (mysql_num_rows(res)) {
        if (!(row = mysql_fetch_row(res))
                || !(lengths = mysql_fetch_lengths(res))) {
            mysql_free_result(res);
            return -1;
        }

        buf = malloc(lengths[0]+8);
#ifdef DEBUG
        syslog(LOG_DEBUG, "sending url '%.*s' to client '%.7s...'", lengths[0], row[0], cl->token);
#endif
        sz = sprintf(buf, "START %s\n", row[0]);

        send(((nolp_t *)(cl->no))->fd, buf, sz, 0);
        free(buf);

        return 0;
    }
    mysql_free_result(res);

    return 1;
}

/** 
 * STATUS command
 **/
static int
on_status(nolp_t *no, char *buf, int size)
{
    struct client *cl;
    int status;

    cl = (struct client*)no->private;
    status = atoi(buf);
    ev_async_send(EV_DEFAULT_ &srv.client_status);

    /** 
     * if status goes to 0, we'll try to find a new
     * URL for this client. If no URL can be found, we'll
     * start a timer that periodically checks for new 
     * URLs.
     **/
    if (status == 0) {
        if (get_and_send_url(cl) != 0) {
            ev_timer_init(&cl->timer, &timer_reached, 5.f, .0f);
            cl->timer.data = cl;
            cl->timer.repeat = 5.f;
            ev_timer_start(cl->loop, &cl->timer);
        }
    }
    cl->running = status;
    return 0;
}

#define Q_URL_1 \
                "INSERT INTO nol_url (url, hash, date)" \
                "VALUES ('"
#define Q_URL_2 \
                "', SHA1(url), NOW())" \
                "ON DUPLICATE KEY UPDATE date=NOW()"
/** 
 * The URL command simply tells us what URL
 * the client is crawling
 **/
static int
on_url(nolp_t *no, char *buf, int size)
{
    struct client *cl;
    char          *q;
    int            x;
    int            sz;
    int            ret = 0;
    cl = (struct client*)no->private;
    sz = size+sizeof(Q_URL_1 Q_URL_2);
    if (!(q = malloc(sz)))
        return -1;

    memcpy(q, Q_URL_1, sizeof(Q_URL_1)-1);

    /* copy the URL, but replace possible '\''
     * with '_' to avoid sql injections */
    for (x=0; x<size; x++) {
        char *p = (q+sizeof(Q_URL_1)-1)+x;
        if (buf[x] == '\'')
            *p = '_';
        else
            *p = buf[x];
    }
    memcpy(q+sizeof(Q_URL_1)-1+size,
           Q_URL_2, sizeof(Q_URL_2));
    if (mysql_real_query(cl->mysql, q, sz) != 0) {
        syslog(LOG_ERR, "updating _url table failed: %s", mysql_error(cl->mysql));
        ret = -1;
    }
    free(q);

    return ret;
}

